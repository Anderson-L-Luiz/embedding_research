and then also attached to it is an arbitrary vector of values . oh . and it can take different types . so they don ' t all have to be floats . you know , you can have integers and you can have doubles and all that sort of stuff . that ' s not what i . . . right , and it has a header . it has a header format that describes it to some extent . so the only problem with it is it ' s actually storing the utterance numbers and the frame numbers in the file , even though they ' re always sequential . and so it does waste a lot of space . but it ' s still a lot tighter than ascii . and we have a lot of tools already to deal with it . is there some documentation on the front ? yeah , there ' s a ton of it . man pages and source code and me . i mean , that sounds good . i was just looking for something . i ' m not a database person , but something sort of standard enough that , you know , if we start using those , we can give it out . other people can work on that . yeah , it ' s not standard . i mean , it ' s something that we developed at icsi . but . . . but it ' s been used here . but it ' s been used here and , you know , we have a well - configured system that you can distribute for free . i mean , it must be the equivalent of whatever you guys use to store your computed features in , right ? yeah , we have . . . actually , we use a generalization of the sphere format . but , yeah , so there ' s something like that . but it ' s . . . i think the word is htk - du for features . or does it even have a concept of features ? i mean , the topic has their own feature format . it ' s called like ssd or something like that . yeah , i ' m just wondering , would it be worthwhile to use that instead ? yeah , this is exactly a good decision . people don ' t typically share this kind of stuff , right ? i mean , they generate their own . actually , i just . . . you know , we ' ve done this stuff on prasadix . and three or four places have asked for those prasadix files . and we just have an ascii . but a frame by frame , which is fine . but it gets unwieldy to go in and query these files with really huge files . and we could do it . i was just thinking if there ' s something . . . and again , if you have a . . . if you have a two - hour long meeting , that ' s gonna . . . they ' re quite large . yeah , i mean , they ' re very much enormous . ten minutes , switchboard conversation . so it ' s doable . it ' s just that you can only store a feature vector at frame by frame . and it doesn ' t have any kind of . . . is the sharing part of this a pretty important consideration ? or is that just sort of a nice thing to have ? i don ' t know enough about what we ' re gonna do with the data . but i thought it would be good to get something that other people can use or adopt for their own kinds of encoding . and we have to make some decision about what to do . and especially for the prasadix work , what it ends up being is you get features from the signal . and of course , those change every time your alignments change . so you rerun a recognize you want to recompute your features . and then keep the database up to date . you change a word or you change an utterance boundary segment , which is gonna happen a lot . and so i wanted something where all of this can be done in an elegant way . and that if somebody wants to try something or compute something else , that it can be done flexibly , doesn ' t have to be pretty . it just has to be easy to use . yeah , the other thing we should look at atlas , the nist thing , and see if they have anything at that level . i mean , i ' m not sure what to do about this with atlas because they chose a different route . i chose something that there are sort of two choices . your file format can know about , know that you ' re talking about language and speech , which is what i chose in time , or your file format can just be a graph representation . and then the application has to impose the structure on top . so what it looked like atlas chose is they chose the other way , which was their file format is just nodes and links . and you have to interpret what they mean yourself . and why did you not choose that ? because i knew that we were doing speech , and i thought it was better if you ' re looking at a raw file to be for the tags to say it ' s an utterance , as opposed to the tag to say it ' s a link . okay . but other than that , are they compatible ? i mean , you could sort of . . . yeah , they ' re reasonably compatible . you could probably translate between them . yeah , that ' s so . . . so , well , the other thing is , if we choose to use atlas , which maybe we should just do , we should just throw this out before we invest a lot of time in it . so this is what the meeting is about , just sort of , how to . . . because we need to come up with the database like this just to do our work . and i actually don ' t care as long as it ' s something useful to other people , what we choose . so maybe it ' s . . . you don ' t have any idea of how to choose because i don ' t . . . yeah . do they already have a whole . . . i chose this for a couple of reasons . one of them is that it ' s easy to parse . you don ' t need a full xml parser . it ' s very easy to just write a purl script to parse it . as long as each tag is on one line . . . exactly , exactly , which i always do . and you can have as much information in the tag as you want , right ? well , i have it structured , right ? so each tag has only particular items that it can take . but you can add to those structures . . . sure . if you . . . if you have more information . so what nist would say is that instead of doing this , you would say something like link . . . start equals some node id . . . and equals some other node id . . . and then type . . . would be utterance . so it ' s very similar . so why would it be a waste to do it this way if it ' s similar enough that we can always translate . . . it probably wouldn ' t be a waste . it would mean that at some point if we wanted to switch , we ' d just have to . . . write a translator , if it ' s linked . since they ' re developing . . . i don ' t think that ' s a big deal . it ' s long as it is . they ' re developing a big infrastructure . and so it seems to me that if . . . if we want to use that , we might as well go directly to what they ' re doing rather than . . . yeah , something that would be useful . yeah , see that ' s the question . i mean , how stable is there . . . are they ready to go ? i looked at it . . . the last time i looked at it was a while ago , probably a year ago . . . when we first started talking about this . and at that time , at least , it was still not very complete . and so , specifically , they didn ' t have any external format representation at that time . they just had sort of conceptual node annotated transcription graph , which i really liked . and that ' s exactly what this stuff is based on . since then , they ' ve developed their own external file format , which is this sort of thing . and apparently , they ' ve also developed a lot of tools , but i haven ' t looked at them . maybe i should . . . maybe with the tools run on something like this . i mean , i guess that ' s the question . what would worry me is that maybe we might miss a little detail . that would make it very difficult to translate from one to the other . it ' s conceptually close . and they already have or will have tools that everybody else will be using . yeah , we might as well . we ' ll be crazy to do something separate . yeah . so i ' ll take a closer look at it . so that would really be the question is just what you feel is in the long run the best thing . because once we start sort of doing this , we don ' t actually have enough time to probably have to rehash it out again . the other way that i sort of established this was as easy translation to and from the transcribe format . right . right . but . . . i mean , i like this . this is sort of intuitively easy to actually read as easy as it could be . but i suppose that as long as they have a type here that specifies . . . it ' s almost the same . the point is with this though is that you can ' t really add any supplementary information . so if you suddenly decide that you want . . . you have to make a different type . yeah , you ' d have to make a different type . so if you look at it , i guess in my mind , i don ' t know enough jane would know better about the types of annotations . but i imagine that those are things that would . . . well , you guys mentioned this that could span any . . . it could